# %%
import streamlit as st
import pandas as pd
import os
import altair as alt
# Plotly removido devido a problemas de compatibilidade com Python 3.13
PLOTLY_AVAILABLE = False
from auth_simple import (verificar_autenticacao, exibir_header_usuario,
                         eh_administrador, verificar_status_aprovado,
                         get_usuarios_cloud, adicionar_usuario_simples, criar_hash_senha,
                         get_modo_operacao, is_modo_cloud)
from datetime import datetime

# Configura√ß√£o otimizada da p√°gina para melhor performance
st.set_page_config(
    page_title="Dashboard KE5Z",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Configura√ß√µes para otimizar conex√£o e performance
if 'connection_optimized' not in st.session_state:
    # Configurar pandas para usar menos mem√≥ria
    pd.set_option('display.max_columns', 50)
    pd.set_option('display.max_rows', 1000)
    
    # Marcar como otimizado
    st.session_state.connection_optimized = True

# Verificar autentica√ß√£o - OBRIGAT√ìRIO no in√≠cio de cada p√°gina
verificar_autenticacao()

# Verificar se o usu√°rio est√° aprovado
if 'usuario_nome' in st.session_state and not verificar_status_aprovado(st.session_state.usuario_nome):
    st.warning("‚è≥ Sua conta ainda est√° pendente de aprova√ß√£o. "
               "Aguarde o administrador aprovar seu acesso.")
    st.info("üìß Voc√™ receber√° uma notifica√ß√£o quando sua conta for "
            "aprovada.")
    st.stop()

# Usar modo selecionado no login (substitui detec√ß√£o autom√°tica)
is_cloud = is_modo_cloud()

# Indicador de navega√ß√£o no topo
st.sidebar.markdown("üìã **NAVEGA√á√ÉO:** Menu de p√°ginas acima ‚¨ÜÔ∏è")
st.sidebar.markdown("---")

# Informar sobre modo selecionado (COMPACTO)
modo_atual = get_modo_operacao()
if modo_atual == 'cloud':
    st.sidebar.info("‚òÅÔ∏è **Modo Cloud**")
else:
    st.sidebar.info("üíª **Modo Completo**")

# Sistema de cache inteligente para otimiza√ß√£o de mem√≥ria e conex√£o
@st.cache_data(
    ttl=3600,
    max_entries=3,  # Aumentar para cachear os 3 arquivos
    show_spinner=True,
    persist="disk"
)
def load_data_optimized(arquivo_tipo="completo"):
    """Carrega dados com otimiza√ß√£o inteligente de mem√≥ria
    
    Args:
        arquivo_tipo: "completo", "main" (sem Others), ou "others"
    """
    
    # Definir qual arquivo carregar
    arquivos_disponiveis = {
        "completo": "KE5Z.parquet",
        "main": "KE5Z_main.parquet", 
        "others": "KE5Z_others.parquet",
        "main_filtered": "KE5Z.parquet"  # Usa arquivo completo mas filtra Others
    }
    
    nome_arquivo = arquivos_disponiveis.get(arquivo_tipo, "KE5Z.parquet")
    arquivo_parquet = os.path.join("KE5Z", nome_arquivo)
    
    try:
        if not os.path.exists(arquivo_parquet):
            # Se arquivo espec√≠fico n√£o existe, tentar arquivo completo
            if arquivo_tipo != "completo":
                st.warning(f"‚ö†Ô∏è Arquivo {nome_arquivo} n√£o encontrado, carregando dados completos...")
                return load_data_optimized("completo")
            raise FileNotFoundError(f"Arquivo n√£o encontrado: {arquivo_parquet}")
        
        # Verificar tamanho do arquivo
        file_size_mb = os.path.getsize(arquivo_parquet) / (1024 * 1024)
        
        # Carregar dados
        df = pd.read_parquet(arquivo_parquet)
        
        # Aplicar filtro especial para main_filtered (cloud mode)
        if arquivo_tipo == "main_filtered" and 'USI' in df.columns:
            # Filtrar para remover Others, simulando arquivo main
            df = df[df['USI'] != 'Others'].copy()
            st.sidebar.info(f"üîÑ Filtro aplicado: {len(df):,} registros (Others removidos)")
        
        # Otimizar tipos de dados para economizar mem√≥ria (sem alterar conte√∫do)
        original_memory = df.memory_usage(deep=True).sum() / (1024 * 1024)
        
        for col in df.columns:
            if df[col].dtype == 'object':
                unique_ratio = df[col].nunique() / len(df)
                if unique_ratio < 0.5:  # Menos de 50% valores √∫nicos
                    df[col] = df[col].astype('category')
        
        # Converter floats para tipos menores
        for col in df.select_dtypes(include=['float64']).columns:
            df[col] = pd.to_numeric(df[col], downcast='float')
        
        # Converter ints para tipos menores
        for col in df.select_dtypes(include=['int64']).columns:
            df[col] = pd.to_numeric(df[col], downcast='integer')
        
        # Calcular economia de mem√≥ria
        optimized_memory = df.memory_usage(deep=True).sum() / (1024 * 1024)
        saved_memory = original_memory - optimized_memory
        
        if saved_memory > 1:  # Economia significativa
            st.sidebar.success(f"üíæ Mem√≥ria economizada: {saved_memory:.1f}MB")
        
        return df
        
    except Exception as e:
        raise e

# Interface para sele√ß√£o de dados (COMPACTO)
st.sidebar.markdown("---")
st.sidebar.markdown("**üóÇÔ∏è Dados**")

# Verificar quais arquivos est√£o dispon√≠veis
arquivos_status = {}
for tipo, nome in [("completo", "KE5Z.parquet"), ("main", "KE5Z_main.parquet"), ("others", "KE5Z_others.parquet")]:
    caminho = os.path.join("KE5Z", nome)
    arquivos_status[tipo] = os.path.exists(caminho)

# Op√ß√µes dispon√≠veis baseadas nos arquivos existentes
opcoes_dados = []

# Priorizar arquivos otimizados sempre
if arquivos_status.get("main", False):
    opcoes_dados.append(("üìä Dados Principais (sem Others)", "main"))

# Apenas Others: OCULTAR no modo cloud
if arquivos_status.get("others", False) and not is_cloud:
    opcoes_dados.append(("üìã Apenas Others", "others"))

# Dados completos: APENAS no modo local E quando n√£o h√° arquivos otimizados
if not is_cloud and arquivos_status.get("completo", False):
    # Se h√° arquivos otimizados, mostrar completo como op√ß√£o adicional
    # Se n√£o h√° arquivos otimizados, ser√° a √∫nica op√ß√£o
    opcoes_dados.append(("üìÅ Dados Completos", "completo"))

# Tratamento especial para Streamlit Cloud
if is_cloud:
    if not opcoes_dados:  # N√£o h√° arquivos otimizados no cloud
        if arquivos_status.get("completo", False):
            # No cloud, usar arquivo completo como "dados principais" temporariamente
            # mas filtrar internamente para remover Others
            opcoes_dados = [("üìä Dados Otimizados (filtrados)", "main_filtered")]
            st.sidebar.warning("‚ö†Ô∏è **Modo Cloud Tempor√°rio**\nUsando arquivo completo com filtro interno.\nPara melhor performance, gere arquivos separados localmente.")
        else:
            st.error("‚ùå **Erro no Streamlit Cloud**: Nenhum arquivo de dados encontrado!")
            st.error("Fa√ßa upload dos arquivos parquet para o reposit√≥rio.")
            st.stop()

# Fallback para modo local sem arquivos otimizados
if not opcoes_dados and not is_cloud:
    if arquivos_status.get("completo", False):
        opcoes_dados = [("üìÅ Dados Completos", "completo")]
    else:
        st.error("‚ùå **Erro**: Nenhum arquivo de dados encontrado!")
        st.error("Execute a extra√ß√£o de dados para gerar os arquivos necess√°rios.")
        st.stop()

# Widget de sele√ß√£o com prioridade para dados principais
def get_default_index():
    """Retorna o √≠ndice padr√£o priorizando dados principais"""
    opcoes_values = [op[1] for op in opcoes_dados]
    
    # Prioridade: main > main_filtered > others > completo
    if "main" in opcoes_values:
        return opcoes_values.index("main")
    elif "main_filtered" in opcoes_values:
        return opcoes_values.index("main_filtered")
    elif "others" in opcoes_values:
        return opcoes_values.index("others")
    else:
        return 0  # Primeiro dispon√≠vel

opcao_selecionada = st.sidebar.selectbox(
    "Escolha o conjunto de dados:",
    options=[op[1] for op in opcoes_dados],
    format_func=lambda x: next(op[0] for op in opcoes_dados if op[1] == x),
    index=get_default_index()  # Priorizar dados principais
)

# Mostrar informa√ß√µes sobre a sele√ß√£o (COMPACTO)
if opcao_selecionada == "main":
    st.sidebar.info("üéØ **Dados Principais** (sem Others)")
elif opcao_selecionada == "main_filtered":
    st.sidebar.info("üéØ **Dados Filtrados** (Cloud)")
elif opcao_selecionada == "others":
    st.sidebar.info("üîç **Apenas Others**")
else:
    st.sidebar.info("üìä **Dados Completos**")

# Carregar dados
try:
    df_total = load_data_optimized(opcao_selecionada)
    st.sidebar.success("‚úÖ Dados carregados com sucesso")
    
    # Log informativo
    if not is_cloud:
        st.sidebar.info(f"üìä {len(df_total)} registros carregados")
        
except FileNotFoundError:
    st.error("‚ùå Arquivo de dados n√£o encontrado!")
    st.error(f"üîç Procurando por: `KE5Z/KE5Z.parquet`")
    st.info("üí° **Solu√ß√µes:**")
    st.info("1. Verifique se o arquivo `KE5Z.parquet` est√° na pasta `KE5Z/`")
    st.info("2. Execute a extra√ß√£o de dados localmente")
    st.info("3. Fa√ßa commit do arquivo no reposit√≥rio")
    
    if is_cloud:
        st.warning("‚òÅÔ∏è **No Streamlit Cloud:** Certifique-se que o arquivo "
                  "foi enviado para o reposit√≥rio")
    
    st.stop()
    
except Exception as e:
    st.error(f"‚ùå Erro ao carregar dados: {str(e)}")
    st.info("üîß **Poss√≠veis causas:**")
    st.info("‚Ä¢ Arquivo corrompido ou formato inv√°lido")
    st.info("‚Ä¢ Problema de permiss√µes")
    st.info("‚Ä¢ Arquivo muito grande")
    
    if is_cloud:
        st.info("‚òÅÔ∏è **No Cloud:** Verifique se o arquivo tem menos de 100MB")
    
    st.stop()

# Filtrar o df_total com a coluna 'USI' que n√£o seja nula (incluindo 'Others')
df_total = df_total[df_total['USI'].notna()]

# Header com informa√ß√µes do usu√°rio e bot√£o de logout
col1, col2, col3 = st.columns([2, 1, 1])
with col1:
    st.title("üìä Dashboard - Visualiza√ß√£o de Dados TC - KE5Z")
st.subheader("Somente os dados com as contas do Per√≠metro TC")

# Exibir header do usu√°rio
exibir_header_usuario()

st.markdown("---")

# Filtros (COMPACTO)
st.sidebar.markdown("---")
st.sidebar.markdown("**üîç Filtros**")

# Cache para op√ß√µes de filtros (otimiza√ß√£o de performance)
@st.cache_data(ttl=1800, max_entries=3)
def get_filter_options(df, column_name):
    """Obt√©m op√ß√µes de filtro com cache para melhor performance"""
    if column_name in df.columns:
        return ["Todos"] + sorted(df[column_name].dropna().astype(str).unique().tolist())
    return ["Todos"]

# Filtro 1: USINA (com cache otimizado)
usina_opcoes = get_filter_options(df_total, 'USI')
default_usina = ["Ve√≠culos"] if "Ve√≠culos" in usina_opcoes else ["Todos"]
usina_selecionada = st.sidebar.multiselect("Selecione a USINA:", usina_opcoes, default=default_usina)

# Filtrar o DataFrame com base na USI
if "Todos" in usina_selecionada or not usina_selecionada:
    df_filtrado = df_total.copy()
else:
    df_filtrado = df_total[df_total['USI'].astype(str).isin(usina_selecionada)]

# Filtro 2: Per√≠odo (com cache otimizado) - usar df_total para op√ß√µes completas
periodo_opcoes = get_filter_options(df_total, 'Per√≠odo')
periodo_selecionado = st.sidebar.selectbox("Selecione o Per√≠odo:", periodo_opcoes)
# Guardar sele√ß√£o para outros gr√°ficos usarem de forma consistente
st.session_state['filtro_periodo_selecionado'] = periodo_selecionado
if periodo_selecionado != "Todos":
    # Converter para float para compara√ß√£o correta com valores num√©ricos
    try:
        periodo_valor = float(periodo_selecionado)
        df_filtrado = df_filtrado[df_filtrado['Per√≠odo'] == periodo_valor]
    except Exception:
        pass

# Filtro 3: Centro cst (com cache otimizado)
if 'Centro cst' in df_filtrado.columns:
    centro_cst_opcoes = get_filter_options(df_total, 'Centro cst')
    centro_cst_selecionado = st.sidebar.selectbox("Selecione o Centro cst:", centro_cst_opcoes)
    if centro_cst_selecionado != "Todos":
        # Compara√ß√£o robusta que funciona com qualquer tipo de dados
        df_filtrado = df_filtrado[df_filtrado['Centro cst'].astype(str) == str(centro_cst_selecionado)]

# Filtro 4: Conta cont√°bil (com cache otimizado)
if 'N¬∫ conta' in df_filtrado.columns:
    conta_contabil_opcoes = get_filter_options(df_total, 'N¬∫ conta')[1:]  # Remove "Todos" para multiselect
    conta_contabil_selecionadas = st.sidebar.multiselect("Selecione a Conta cont√°bil:", conta_contabil_opcoes)
    if conta_contabil_selecionadas:
        df_filtrado = df_filtrado[df_filtrado['N¬∫ conta'].astype(str).isin(conta_contabil_selecionadas)]

# Filtros principais (com cache otimizado)
filtros_principais = [
    ("Type 05", "Type 05", "multiselect"),
    ("Type 06", "Type 06", "multiselect"), 
    ("Type 07", "Type 07", "multiselect"),
    ("Fornecedor", "Fornecedor", "multiselect"),
    ("Fornec.", "Fornec.", "multiselect"),
    ("Tipo", "Tipo", "multiselect")
]

for col_name, label, widget_type in filtros_principais:
    if col_name in df_filtrado.columns:
        opcoes = get_filter_options(df_total, col_name)
        if widget_type == "multiselect":
            selecionadas = st.sidebar.multiselect(f"Selecione o {label}:", opcoes, default=["Todos"])
            if selecionadas and "Todos" not in selecionadas:
                df_filtrado = df_filtrado[df_filtrado[col_name].astype(str).isin(selecionadas)]

# Filtros avan√ßados (expans√≠vel)
with st.sidebar.expander("üîç Filtros Avan√ßados"):
    filtros_avancados = [
        ("Oficina", "Oficina", "multiselect"),
        ("Usu√°rio", "Usu√°rio", "multiselect"),
        ("Denomina√ß√£o", "Denomina√ß√£o", "multiselect"),
        ("Dt.l√ßto.", "Data Lan√ßamento", "multiselect")
    ]
    
    for col_name, label, widget_type in filtros_avancados:
        if col_name in df_filtrado.columns:
            opcoes = get_filter_options(df_total, col_name)
            # Limitar op√ß√µes para melhor performance
            if len(opcoes) > 101:  # 100 + "Todos"
                opcoes = opcoes[:101]
                st.caption(f"‚ö†Ô∏è {label}: Limitado a 100 op√ß√µes para performance")
            
            if widget_type == "multiselect":
                selecionadas = st.multiselect(f"Selecione o {label}:", opcoes, default=["Todos"])
                if selecionadas and "Todos" not in selecionadas:
                    df_filtrado = df_filtrado[df_filtrado[col_name].astype(str).isin(selecionadas)]

# Resumo (COMPACTO)
st.sidebar.markdown("---")
st.sidebar.markdown("**üìä Resumo**")
st.sidebar.write(f"**Linhas:** {df_filtrado.shape[0]:,}")
st.sidebar.write(f"**Total:** R$ {df_filtrado['Valor'].sum():,.2f}")

# Status do Sistema (COMPACTO)
if not is_cloud:  # S√≥ mostrar em modo local para economizar espa√ßo
    st.sidebar.markdown("---")
    st.sidebar.markdown("**üíæ Sistema**")
    
    try:
        import sys
        df_size_mb = sys.getsizeof(df_filtrado) / (1024 * 1024)
        st.sidebar.write(f"**Mem√≥ria:** {df_size_mb:.1f}MB")
        
        if st.sidebar.button("üßπ Cache", help="Limpar cache"):
            st.cache_data.clear()
            import gc
            gc.collect()
            st.sidebar.success("‚úÖ Limpo!")
            st.rerun()
    except Exception:
        pass

# √Årea administrativa (COMPACTO)
if eh_administrador():
    st.sidebar.markdown("---")
    st.sidebar.markdown("**üëë Admin**")

    usuarios = get_usuarios_cloud()
    total_usuarios = len(usuarios)
    usuarios_aprovados = len([u for u in usuarios.values() if u.get('status') == 'aprovado'])
    usuarios_pendentes = len([u for u in usuarios.values() if u.get('status') == 'pendente'])

    st.sidebar.write(f"**Usu√°rios:** {total_usuarios} ({usuarios_aprovados} ‚úÖ, {usuarios_pendentes} ‚è≥)")
    
    # Bot√£o para expandir detalhes
    if st.sidebar.button("üìã Ver Usu√°rios"):
        st.sidebar.markdown("**Cadastrados:**")
        for usuario, dados in usuarios.items():
            tipo_icon = "üëë" if dados.get('tipo') == 'administrador' else "üë•"
            status_icon = "‚úÖ" if dados.get('status') == 'aprovado' else "‚è≥"
            st.sidebar.write(f"{tipo_icon} {status_icon} {usuario}")

# Gr√°fico de barras para a soma dos valores por 'Per√≠odo'
@st.cache_data(ttl=900, max_entries=2)
def create_period_chart(df_data):
    """Cria gr√°fico otimizado"""
    try:
        chart_data = df_data.groupby('Per√≠odo')['Valor'].sum().reset_index()
        
        grafico_barras = alt.Chart(chart_data).mark_bar().encode(
            x=alt.X('Per√≠odo:N', title='Per√≠odo'),
            y=alt.Y('Valor:Q', title='Soma do Valor'),
            color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
            tooltip=['Per√≠odo:N', 'Valor:Q']
        ).properties(
            title='Soma do Valor por Per√≠odo'
        )
        
        return grafico_barras
    except Exception as e:
        st.error(f"Erro ao criar gr√°fico: {e}")
        return None

# Criar e exibir gr√°fico
grafico_barras = create_period_chart(df_filtrado)
if grafico_barras:
    # Adicionar r√≥tulos com valores nas barras
    rotulos = grafico_barras.mark_text(
        align='center',
        baseline='middle',
        dy=-10,  # Ajuste vertical
        color='black',
        fontSize=12
    ).encode(
        text=alt.Text('Valor:Q', format=',.2f')
    )
    
    # Combinar gr√°fico com r√≥tulos
    grafico_completo = grafico_barras + rotulos
    st.altair_chart(grafico_completo, use_container_width=True)

# Gr√°ficos adicionais por Type
st.subheader("üìä An√°lise por Categorias")

# Gr√°fico por Type 05
if 'Type 05' in df_filtrado.columns:
    @st.cache_data(ttl=900, max_entries=2)
    def create_type05_chart(df_data):
        try:
            # Aplicar filtro de m√™s consistente (caso a filtragem global falhe)
            sel = st.session_state.get('filtro_periodo_selecionado', 'Todos')
            if sel != 'Todos' and 'Per√≠odo' in df_data.columns:
                try:
                    df_data = df_data[pd.to_numeric(df_data['Per√≠odo'], errors='coerce') == float(sel)]
                except Exception:
                    pass
            type05_data = df_data.groupby('Type 05')['Valor'].sum().reset_index()
            type05_data = type05_data.sort_values('Valor', ascending=False)
            
            chart = alt.Chart(type05_data).mark_bar().encode(
                x=alt.X('Type 05:N', title='Type 05', sort='-y'),
                y=alt.Y('Valor:Q', title='Soma do Valor'),
                color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
                tooltip=['Type 05:N', 'Valor:Q']
            ).properties(
                title=f"Soma do Valor por Type 05{'' if sel=='Todos' else f' - M√™s {sel:g}'}",
                height=400
            )
            
            return chart
        except Exception as e:
            st.error(f"Erro no gr√°fico Type 05: {e}")
            return None
    
    chart_type05 = create_type05_chart(df_filtrado)
    if chart_type05:
        st.altair_chart(chart_type05, use_container_width=True)

# Gr√°fico por Type 06
if 'Type 06' in df_filtrado.columns:
    @st.cache_data(ttl=900, max_entries=2)
    def create_type06_chart(df_data):
        try:
            # Aplicar filtro de m√™s consistente (caso a filtragem global falhe)
            sel = st.session_state.get('filtro_periodo_selecionado', 'Todos')
            if sel != 'Todos' and 'Per√≠odo' in df_data.columns:
                try:
                    df_data = df_data[pd.to_numeric(df_data['Per√≠odo'], errors='coerce') == float(sel)]
                except Exception:
                    pass
            type06_data = df_data.groupby('Type 06')['Valor'].sum().reset_index()
            type06_data = type06_data.sort_values('Valor', ascending=False)
            
            chart = alt.Chart(type06_data).mark_bar().encode(
                x=alt.X('Type 06:N', title='Type 06', sort='-y'),
                y=alt.Y('Valor:Q', title='Soma do Valor'),
                color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
                tooltip=['Type 06:N', 'Valor:Q']
            ).properties(
                title=f"Soma do Valor por Type 06{'' if sel=='Todos' else f' - M√™s {sel:g}'}",
                height=400
            )
            
            return chart
        except Exception as e:
            st.error(f"Erro no gr√°fico Type 06: {e}")
            return None
    
    chart_type06 = create_type06_chart(df_filtrado)
    if chart_type06:
        st.altair_chart(chart_type06, use_container_width=True)

# Gr√°fico por Texto (mesmo modelo e cores)
texto_col = None
for candidate in ['Texto', 'Texto breve', 'Descri√ß√£o Material']:
    if candidate in df_filtrado.columns:
        texto_col = candidate
        break

if texto_col:
    # Controles espec√≠ficos acima do gr√°fico
    col_mes, col_t7, col_top = st.columns([1, 2, 1])

    # Filtro de m√™s (Per√≠odo)
    meses_opcoes = ["Todos"]
    if 'Per√≠odo' in df_filtrado.columns:
        try:
            meses = sorted([m for m in pd.to_numeric(df_filtrado['Per√≠odo'], errors='coerce').dropna().unique().tolist()])
            meses_opcoes += meses
        except Exception:
            pass
    mes_sel = col_mes.selectbox("M√™s (Per√≠odo)", meses_opcoes, index=0)

    # Filtro de Type 07
    type07_opcoes = ["Todos"]
    if 'Type 07' in df_filtrado.columns:
        type07_opcoes += sorted(df_filtrado['Type 07'].dropna().astype(str).unique().tolist())
    type07_sel = col_t7.multiselect("Type 07", type07_opcoes, default=["Todos"]) 

    # Limitador (Pareto)
    top_map = {"Top 10": 10, "Top 15": 15, "Top 20": 20, "Total": None}
    top_label = col_top.selectbox("Limite (Pareto)", list(top_map.keys()), index=0)
    top_n = top_map[top_label]

    @st.cache_data(ttl=900, max_entries=2)
    def create_texto_chart(df_data, col_name, top_n_param):
        try:
            texto_data = (
                df_data.assign(**{col_name: df_data[col_name].astype(str)})
                .groupby(col_name)['Valor']
                .sum()
                .reset_index()
                .sort_values('Valor', ascending=False)
            )
            if top_n_param is not None and len(texto_data) > top_n_param:
                texto_data = texto_data.head(top_n_param)

            chart = alt.Chart(texto_data).mark_bar().encode(
                x=alt.X(f'{col_name}:N', title=col_name, sort='-y'),
                y=alt.Y('Valor:Q', title='Soma do Valor'),
                color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
                tooltip=[f'{col_name}:N', 'Valor:Q']
            ).properties(
                title=f'Soma do Valor por {col_name}',
                height=400
            )
            return chart
        except Exception as e:
            st.error(f"Erro no gr√°fico {col_name}: {e}")
            return None

    # Aplicar filtros locais para o gr√°fico
    df_texto = df_filtrado.copy()
    if mes_sel != "Todos" and 'Per√≠odo' in df_texto.columns:
        try:
            df_texto = df_texto[pd.to_numeric(df_texto['Per√≠odo'], errors='coerce') == float(mes_sel)]
        except Exception:
            pass
    if type07_sel and "Todos" not in type07_sel and 'Type 07' in df_texto.columns:
        df_texto = df_texto[df_texto['Type 07'].astype(str).isin(type07_sel)]

    chart_texto = create_texto_chart(df_texto, texto_col, top_n)
    if chart_texto:
        st.altair_chart(chart_texto, use_container_width=True)

# Tabela din√¢mica com cores
df_pivot = df_filtrado.pivot_table(
    index='USI', columns='Per√≠odo', values='Valor', aggfunc='sum',
    margins=True, margins_name='Total', fill_value=0
)

# Remover linhas totalmente zeradas (exceto a linha Total) para compactar a visualiza√ß√£o
if not df_pivot.empty:
    colunas_sem_total = [c for c in df_pivot.columns if c != 'Total']
    if colunas_sem_total:
        mask_totalmente_zero = (df_pivot[colunas_sem_total].sum(axis=1) == 0)
    else:
        mask_totalmente_zero = (df_pivot.sum(axis=1) == 0)
    df_pivot_compact = df_pivot.loc[~((df_pivot.index != 'Total') & mask_totalmente_zero)]
else:
    df_pivot_compact = df_pivot
st.subheader("Tabela Din√¢mica - Soma do Valor por USI e Per√≠odo")

# Aplicar formata√ß√£o com cores (verde para positivo, vermelho para negativo)
def colorir_valores(val):
    if isinstance(val, (int, float)):
        if val < 0:
            return 'color: #e74c3c; font-weight: bold;'  # Vermelho para negativo
        elif val > 0:
            return 'color: #27ae60; font-weight: bold;'  # Verde para positivo
    return ''

styled_pivot = df_pivot_compact.style.format('R$ {:,.2f}').map(colorir_valores, subset=pd.IndexSlice[:, :])

# Altura din√¢mica para evitar "linhas vazias" visuais
num_rows = len(df_pivot_compact)
altura = max(220, min(600, 64 + 32 * num_rows))  # cabe√ßalho + altura por linha
st.dataframe(styled_pivot, use_container_width=True, height=altura)

# Bot√£o de download da Tabela Din√¢mica (logo abaixo da tabela)
if st.button("üì• Baixar Tabela Din√¢mica (Excel)", use_container_width=True, key="download_pivot"):
    with st.spinner("Gerando arquivo da tabela din√¢mica..."):
        # Fun√ß√£o para exportar para Excel
        def exportar_excel_pivot(df, nome_arquivo):
            from io import BytesIO
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, index=True, sheet_name='Tabela_Dinamica')
            output.seek(0)
            return output.getvalue()
        
        excel_data_pivot = exportar_excel_pivot(df_pivot, 'KE5Z_tabela_dinamica.xlsx')
        
        # For√ßar download usando JavaScript
        import base64
        b64 = base64.b64encode(excel_data_pivot).decode()
        href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_tabela_dinamica.xlsx">üíæ Clique aqui para baixar a Tabela Din√¢mica</a>'
        st.markdown(href, unsafe_allow_html=True)
        st.success("‚úÖ Tabela Din√¢mica gerada! Clique no link acima para baixar.")

# Exibir o DataFrame filtrado (limitado para performance)
st.subheader("Tabela Filtrada")
display_limit = 500 if is_cloud else 2000
if len(df_filtrado) > display_limit:
    st.info(f"üìä Mostrando {display_limit:,} de {len(df_filtrado):,} registros para otimizar performance")
    df_display = df_filtrado.head(display_limit)
else:
    df_display = df_filtrado

st.dataframe(df_display, use_container_width=True, height=600)

# Bot√£o de download da Tabela Filtrada (logo abaixo da tabela)
if st.button("üì• Baixar Tabela Filtrada (Excel)", use_container_width=True, key="download_filtered"):
    with st.spinner("Gerando arquivo da tabela filtrada..."):
        # Fun√ß√£o para exportar tabela filtrada
        def exportar_excel_filtrada(df, nome_arquivo):
            from io import BytesIO
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name='Dados_Filtrados')
            output.seek(0)
            return output.getvalue()
        
        excel_data_filtrada = exportar_excel_filtrada(df_filtrado, 'KE5Z_tabela_filtrada.xlsx')
        
        # For√ßar download usando JavaScript
        import base64
        b64 = base64.b64encode(excel_data_filtrada).decode()
        href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_tabela_filtrada.xlsx">üíæ Clique aqui para baixar a Tabela Filtrada</a>'
        st.markdown(href, unsafe_allow_html=True)
        st.success("‚úÖ Tabela Filtrada gerada! Clique no link acima para baixar.")

## Tabela de soma por Types (Type 05, Type 06, Type 07)
if all(col in df_filtrado.columns for col in ['Type 05', 'Type 06', 'Type 07']):
    st.markdown("---")
    st.subheader("üìä Soma por Type 05, Type 06 e Type 07")

    # Op√ß√µes
    ocultar_zeros = st.checkbox("Ocultar linhas com valor R$ 0,00", value=True, key="agg_hide_zero_types")

    # Preparar dados SEMPRE do arquivo waterfall
    caminho_wf = os.path.join('KE5Z', 'KE5Z_waterfall.parquet')
    if not os.path.exists(caminho_wf):
        st.error('‚ùå Arquivo waterfall n√£o encontrado: KE5Z/KE5Z_waterfall.parquet')
        st.info('Execute a extra√ß√£o para gerar o arquivo waterfall.')
        tabela_final = pd.DataFrame({'Type 05': [], 'Type 06': [], 'Type 07': [], 'Valor': []})
    else:
        df_w = pd.read_parquet(caminho_wf, columns=['Per√≠odo','USI','Type 05','Type 06','Type 07','Valor'])
        # Aplicar filtros b√°sicos equivalentes (USI e Per√≠odo) conforme df_filtrado atual
        try:
            if 'USI' in df_filtrado.columns and not df_filtrado.empty:
                usi_vals = df_filtrado['USI'].dropna().unique().tolist()
                if len(usi_vals) > 0:
                    df_w = df_w[df_w['USI'].astype(str).isin([str(v) for v in usi_vals])]
            if 'Per√≠odo' in df_filtrado.columns and not df_filtrado.empty:
                per_vals = df_filtrado['Per√≠odo'].dropna().unique().tolist()
                if len(per_vals) > 0:
                    df_w = df_w[df_w['Per√≠odo'].isin(per_vals)]
        except Exception:
            pass

        df_w['Valor'] = pd.to_numeric(df_w.get('Valor'), errors='coerce').fillna(0)
        for col_name in ['Type 05', 'Type 06', 'Type 07']:
            if col_name in df_w.columns:
                df_w[col_name] = df_w[col_name].astype('string').fillna('(vazio)')

        soma_por_type = (
            df_w.groupby(['Type 05', 'Type 06', 'Type 07'], dropna=False)['Valor']
            .sum()
            .reset_index()
        )

    if ocultar_zeros:
        soma_por_type = soma_por_type[soma_por_type['Valor'].abs() > 0.0049]

    # Ordenar por valor desc para leitura
    if not soma_por_type.empty:
        soma_por_type = soma_por_type.sort_values('Valor', ascending=False)

    # Linha de total
    total_val = float(soma_por_type['Valor'].sum()) if not soma_por_type.empty else 0.0
    soma_total = pd.DataFrame({
        'Type 05': ['Total'], 'Type 06': [''], 'Type 07': [''], 'Valor': [total_val]
    })
    tabela_final = pd.concat([soma_por_type, soma_total], ignore_index=True)

    # Exibir
    def colorir_valores(val):
        if isinstance(val, (int, float)):
            if val < 0:
                return 'color: #e74c3c; font-weight: bold;'
            elif val > 0:
                return 'color: #27ae60; font-weight: bold;'
        return ''

    styled = tabela_final.style.format({'Valor': 'R$ {:,.2f}'}).map(colorir_valores, subset=['Valor'])
    st.dataframe(styled, use_container_width=True, height=500)

    # Download
    if st.button("üì• Baixar Soma por Types (Excel)", use_container_width=True, key="agg_download_types"):
        with st.spinner("Gerando arquivo da soma por types..."):
            from io import BytesIO
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                tabela_final.to_excel(writer, index=False, sheet_name='Soma_por_Types')
            output.seek(0)
            import base64
            b64 = base64.b64encode(output.getvalue()).decode()
            href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_soma_por_types.xlsx">üíæ Clique aqui para baixar a Soma por Types</a>'
            st.markdown(href, unsafe_allow_html=True)

# Footer
st.markdown("---")
st.info("üí° Dashboard KE5Z com otimiza√ß√µes de cache e mem√≥ria")

# Informa√ß√µes de funcionalidades restauradas
col1, col2, col3 = st.columns(3)
with col1:
    st.success("‚úÖ Exporta√ß√£o Excel")
with col2:
    st.success("‚úÖ Gr√°ficos Coloridos")
with col3:
    st.success("‚úÖ Tabelas com Cores")

if is_cloud:
    st.success("‚òÅÔ∏è Executando no Streamlit Cloud com otimiza√ß√µes")
else:
    st.success("üíª Executando localmente com performance m√°xima")